package uk.gov.di.authentication.frontendapi.contract;

import au.com.dius.pact.consumer.MockServer;
import au.com.dius.pact.consumer.dsl.PactDslWithProvider;
import au.com.dius.pact.consumer.junit.MockServerConfig;
import au.com.dius.pact.consumer.junit5.PactConsumerTest;
import au.com.dius.pact.consumer.junit5.PactTestFor;
import au.com.dius.pact.core.model.PactSpecVersion;
import au.com.dius.pact.core.model.RequestResponsePact;
import au.com.dius.pact.core.model.annotations.Pact;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.JWSHeader;
import com.nimbusds.jose.crypto.impl.ECDSA;
import com.nimbusds.oauth2.sdk.TokenResponse;
import com.nimbusds.oauth2.sdk.id.ClientID;
import com.nimbusds.oauth2.sdk.id.JWTID;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import software.amazon.awssdk.core.SdkBytes;
import software.amazon.awssdk.services.kms.model.GetPublicKeyRequest;
import software.amazon.awssdk.services.kms.model.GetPublicKeyResponse;
import software.amazon.awssdk.services.kms.model.SignRequest;
import software.amazon.awssdk.services.kms.model.SignResponse;
import software.amazon.awssdk.services.kms.model.SigningAlgorithmSpec;
import uk.gov.di.authentication.frontendapi.services.ReverificationResultService;
import uk.gov.di.authentication.shared.helpers.HashHelper;
import uk.gov.di.authentication.shared.helpers.NowHelper;
import uk.gov.di.authentication.shared.services.ConfigurationService;
import uk.gov.di.authentication.shared.services.KmsConnectionService;

import java.net.URI;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Base64;
import java.util.Date;

import static au.com.dius.pact.consumer.dsl.LambdaDsl.newJsonBody;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.mockConstruction;
import static org.mockito.Mockito.when;

@PactConsumerTest
@MockServerConfig(hostInterface = "localHost", port = "1234")
class IpvTokenTest {
    private final ConfigurationService configService = mock(ConfigurationService.class);
    private final KmsConnectionService kmsConnectionService = mock(KmsConnectionService.class);
    private ReverificationResultService reverificationResultService;

    private static final String IPV_AUD = "http://ipv/";
    private static final URI IPV_URI = URI.create(IPV_AUD);
    private static final ClientID CLIENT_ID = new ClientID("authOrchestrator");
    private static final String IPV_TOKEN_PATH = "token";
    private static final String ACCESS_TOKEN_FIELD = "access_token";
    private static final String TOKEN_TYPE_FIELD = "token_type";
    private static final String EXPIRES_IN_FIELD = "expires_in";
    private static final String ACCESS_TOKEN_VALUE = "740e5834-3a29-46b4-9a6f-16142fde533a";
    private static final String TOKEN_TYPE_VALUE = "Bearer";
    private static final Integer EXPIRES_IN_VALUE = 3600;
    private static final String KEY_ID = "14342354354353";
    private static final String KEY_ID_HASHED = HashHelper.hashSha256String(KEY_ID);

    // Generated by debugging reverificationResultService when creating EC signing key
    private static final String PRIVATE_JWT_KEY =
            "{\"kty\":\"EC\",\"d\":\"4NLo4B5Oj5E_ga6-eYjTSehss85p_mL799NRQqmll64\",\"crv\":\"P-256\",\"kid\":\"14342354354353\",\"x\":\"emDeRQ0KISC_TdfkoAZdd4lWm2Nk5UOtmmboLEab850\",\"y\":\"-Ua4zzSzMG5lgpMyZoURg6Au60mHSxgnnf9pDtJmE2w\",\"alg\":\"ES256\"}";
    // Generated by debugging the token service when creating the request - using SHA256 hash of
    // KEY_ID
    private static final String CLIENT_ASSERTION_HEADER =
            new JWSHeader.Builder(JWSAlgorithm.ES256)
                    .keyID(KEY_ID_HASHED)
                    .build()
                    .toBase64URL()
                    .toString();
    private static final String CLIENT_ASSERTION_BODY =
            "eyJzdWIiOiJhdXRoT3JjaGVzdHJhdG9yIiwiYXVkIjoiaHR0cDovL2lwdi8iLCJuYmYiOjk0NjY4NDgwMCwiaXNzIjoiYXV0aE9yY2hlc3RyYXRvciIsImV4cCI6NDA3MDkwODgwMCwiaWF0Ijo5NDY2ODQ4MDAsImp0aSI6IjEifQ";
    // Generated from jwt.io by using PRIVATE_JWT_KEY
    private static final String CLIENT_ASSERTION_SIGNATURE =
            "ug2Yl23vA5c1KCN2CF2zFEz7v8WMCqKOoaYIitAb7UWSeRO8osltQhjhPp9L9U1NJnuuZc0J0u_QNOqYajpWPQ";

    @BeforeEach
    void setUp() {
        reverificationResultService =
                new ReverificationResultService(configService, kmsConnectionService);
        when(configService.getIPVAuthorisationClientId()).thenReturn(CLIENT_ID.getValue());
        when(configService.getIPVAudience()).thenReturn(IPV_URI.toString());
        when(configService.getMfaResetJarSigningKeyAlias()).thenReturn(KEY_ID);
        when(configService.getMfaResetJarSigningKeyId()).thenReturn(KEY_ID);
        when(kmsConnectionService.getPublicKey(any(GetPublicKeyRequest.class)))
                .thenReturn(GetPublicKeyResponse.builder().keyId(KEY_ID).build());
        when(kmsConnectionService.sign(any(SignRequest.class))).thenReturn(mockKmsReturn());
    }

    @Pact(consumer = "AuthTokenConsumer")
    RequestResponsePact validRequestReturnsValidAccessToken(PactDslWithProvider builder) {
        return builder.given("dummyAuthCode is a valid authorization code")
                .given("the JWT is signed with " + PRIVATE_JWT_KEY)
                .given("the audience is " + IPV_AUD)
                .uponReceiving("Valid auth code")
                .path("/" + IPV_TOKEN_PATH)
                .method("POST")
                .body(
                        "client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer&"
                                + "code=dummyAuthCode&"
                                + "grant_type=authorization_code&"
                                + "client_assertion="
                                + CLIENT_ASSERTION_HEADER
                                + "."
                                + CLIENT_ASSERTION_BODY
                                + "."
                                + CLIENT_ASSERTION_SIGNATURE
                                + "&"
                                + "client_id="
                                + CLIENT_ID.getValue())
                .matchHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
                .willRespondWith()
                .status(200)
                .body(
                        newJsonBody(
                                        body -> {
                                            body.stringType(ACCESS_TOKEN_FIELD, ACCESS_TOKEN_VALUE);
                                            body.stringType(TOKEN_TYPE_FIELD, TOKEN_TYPE_VALUE);
                                            body.integerType(EXPIRES_IN_FIELD, EXPIRES_IN_VALUE);
                                        })
                                .build())
                .toPact();
    }

    @Test
    @PactTestFor(
            providerName = "IpvCoreBackTokenProvider",
            pactMethod = "validRequestReturnsValidAccessToken",
            pactVersion = PactSpecVersion.V3)
    void getIPVTokenSuccessResponse(MockServer mockServer) {
        when(configService.getIPVBackendURI()).thenReturn(URI.create(mockServer.getUrl()));

        TokenResponse tokenResponse;
        try (MockedStatic<NowHelper> mockedNowHelperClass = Mockito.mockStatic(NowHelper.class)) {
            mockedNowHelperClass
                    .when(NowHelper::now)
                    .thenReturn(Date.from(Instant.parse("2000-01-01T00:00:00.00Z")));
            mockedNowHelperClass
                    .when(() -> NowHelper.nowPlus(5L, ChronoUnit.MINUTES))
                    .thenReturn(Date.from(Instant.parse("2099-01-01T00:00:00.00Z")));
            try (var mockJwtId =
                    mockConstruction(
                            JWTID.class,
                            (mock, context) -> {
                                when(mock.getValue()).thenReturn("1");
                            })) {
                tokenResponse = reverificationResultService.getToken("dummyAuthCode");
            }
        }

        assertThat(tokenResponse.indicatesSuccess(), equalTo(true));
        assertThat(
                tokenResponse.toSuccessResponse().getTokens().toString(),
                equalTo(getSuccessfulTokenHttpResponse()));
    }

    @Pact(consumer = "AuthTokenConsumer")
    RequestResponsePact invalidAuthCodeReturnsInvalidRequest(PactDslWithProvider builder) {
        return builder.given("dummyInvalidAuthCode is a invalid authorization code")
                .given("the JWT is signed with " + PRIVATE_JWT_KEY)
                .given("the audience is " + IPV_AUD)
                .uponReceiving("Invalid auth code")
                .path("/" + IPV_TOKEN_PATH)
                .method("POST")
                .body(
                        "client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer&"
                                + "code=dummyInvalidAuthCode&"
                                + "grant_type=authorization_code&"
                                + "client_assertion="
                                + CLIENT_ASSERTION_HEADER
                                + "."
                                + CLIENT_ASSERTION_BODY
                                + "."
                                + CLIENT_ASSERTION_SIGNATURE
                                + "&"
                                + "client_id="
                                + CLIENT_ID.getValue())
                .matchHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
                .willRespondWith()
                .status(400)
                .toPact();
    }

    @Test
    @PactTestFor(
            providerName = "IpvCoreBackTokenProvider",
            pactMethod = "invalidAuthCodeReturnsInvalidRequest",
            pactVersion = PactSpecVersion.V3)
    void getIPVTokenErrorResponse(MockServer mockServer) {
        when(configService.getIPVBackendURI()).thenReturn(URI.create(mockServer.getUrl()));

        TokenResponse tokenResponse;
        try (MockedStatic<NowHelper> mockedNowHelperClass = Mockito.mockStatic(NowHelper.class)) {
            mockedNowHelperClass
                    .when(NowHelper::now)
                    .thenReturn(Date.from(Instant.parse("2000-01-01T00:00:00.00Z")));
            mockedNowHelperClass
                    .when(() -> NowHelper.nowPlus(5L, ChronoUnit.MINUTES))
                    .thenReturn(Date.from(Instant.parse("2099-01-01T00:00:00.00Z")));
            try (var mockJwtId =
                    mockConstruction(
                            JWTID.class,
                            (mock, context) -> {
                                when(mock.getValue()).thenReturn("1");
                            })) {
                tokenResponse = reverificationResultService.getToken("dummyInvalidAuthCode");
            }
        }

        assertThat(tokenResponse.indicatesSuccess(), equalTo(false));
        assertThat(tokenResponse.toHTTPResponse().getStatusCode(), equalTo(400));
    }

    private SignResponse mockKmsReturn() {
        byte[] signatureBytes;

        try {
            signatureBytes =
                    ECDSA.transcodeSignatureToDER(
                            Base64.getUrlDecoder().decode(CLIENT_ASSERTION_SIGNATURE));
        } catch (JOSEException e) {
            throw new RuntimeException(e);
        }

        return SignResponse.builder()
                .signature(SdkBytes.fromByteArray(signatureBytes))
                .signingAlgorithm(SigningAlgorithmSpec.ECDSA_SHA_256)
                .keyId(KEY_ID)
                .build();
    }

    public String getSuccessfulTokenHttpResponse() {
        return "{"
                + "\""
                + ACCESS_TOKEN_FIELD
                + "\":\""
                + ACCESS_TOKEN_VALUE
                + "\","
                + "\""
                + TOKEN_TYPE_FIELD
                + "\":\""
                + TOKEN_TYPE_VALUE
                + "\","
                + "\""
                + EXPIRES_IN_FIELD
                + "\":"
                + EXPIRES_IN_VALUE
                + "}";
    }
}
