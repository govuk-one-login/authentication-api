package uk.gov.di.authentication.app.contract;

import au.com.dius.pact.consumer.MockServer;
import au.com.dius.pact.consumer.dsl.PactDslWithProvider;
import au.com.dius.pact.consumer.junit.MockServerConfig;
import au.com.dius.pact.consumer.junit5.PactConsumerTest;
import au.com.dius.pact.consumer.junit5.PactTestFor;
import au.com.dius.pact.core.model.PactSpecVersion;
import au.com.dius.pact.core.model.RequestResponsePact;
import au.com.dius.pact.core.model.annotations.Pact;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.crypto.impl.ECDSA;
import com.nimbusds.oauth2.sdk.TokenRequest;
import com.nimbusds.oauth2.sdk.TokenResponse;
import com.nimbusds.oauth2.sdk.id.Audience;
import com.nimbusds.oauth2.sdk.id.ClientID;
import com.nimbusds.oauth2.sdk.id.JWTID;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import software.amazon.awssdk.core.SdkBytes;
import software.amazon.awssdk.services.kms.model.*;
import uk.gov.di.authentication.app.services.DocAppCriService;
import uk.gov.di.orchestration.shared.api.DocAppCriAPI;
import uk.gov.di.orchestration.shared.helpers.NowHelper;
import uk.gov.di.orchestration.shared.services.ConfigurationService;
import uk.gov.di.orchestration.shared.services.KmsConnectionService;

import java.net.URI;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Base64;
import java.util.Date;

import static au.com.dius.pact.consumer.dsl.LambdaDsl.newJsonBody;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;
import static org.mockito.Mockito.*;

@PactConsumerTest
@MockServerConfig(hostInterface = "localHost", port = "1234")
public class DcmawTokenTest {
    private final ConfigurationService configService = mock(ConfigurationService.class);
    private final KmsConnectionService kmsConnectionService = mock(KmsConnectionService.class);
    private DocAppCriService docAppCriService;

    private static final String DOC_APP_AUD = "https://www.review-b.account.gov.uk/";
    private static final ClientID CLIENT_ID = new ClientID("authOrchestratorDocApp");
    private static final String DOC_APP_TOKEN_PATH = "token";
    private final String ACCESS_TOKEN_FIELD = "access_token";
    private final String TOKEN_TYPE_FIELD = "token_type";
    private final String EXPIRES_IN_FIELD = "expires_in";
    private final String URI_FIELD = "uri";
    private final String ACCESS_TOKEN_VALUE = "740e5834-3a29-46b4-9a6f-16142fde533a";
    private final String TOKEN_TYPE_VALUE = "Bearer";
    private final Integer EXPIRES_IN_VALUE = 3600;
    private final String URI_VALUE = "https://localhost";

    // Generated by debugging tokenServiceTest when creating EC signing key
    private static final String PRIVATE_JWT_KEY =
            "{\"kty\":\"EC\",\"d\":\"BA8NW8FUlcrCAqH3VypCDUZiFIerhTaB1soA0ddTYRc\",\"crv\":\"P-256\",\"kid\":\"14342354354353\",\"x\":\"LySEL-BpYynl4XO0L-dDjduRgq4mrmKI34yBH8ADbj8\",\"y\":\"OXqT3mDgeJuT2FEfxi1vWW7etVn23HUd9m1WTffPh-w\",\"alg\":\"ES256\"}";
    private static final String KEY_ID = "14342354354353";
    // Generated by debugging the token service when creating the request
    private static final String CLIENT_ASSERTION_HEADER =
            "eyJraWQiOiJmMTdkYTg2NjlhOTUxYWZjM2ZiNDk5ZTkwMTE4NmQ3N2U5OWFmMjNiNWQxOTYyZDNjZTg1ZTlkNmM4MmQzYTY5IiwiYWxnIjoiRVMyNTYifQ";
    private static final String CLIENT_ASSERTION_BODY =
            "eyJzdWIiOiJhdXRoT3JjaGVzdHJhdG9yRG9jQXBwIiwiYXVkIjoiaHR0cHM6Ly93d3cucmV2aWV3LWIuYWNjb3VudC5nb3YudWsvIiwibmJmIjo5NDY2ODQ4MDAsImlzcyI6ImF1dGhPcmNoZXN0cmF0b3JEb2NBcHAiLCJleHAiOjQwNzA5MDg4MDAsImlhdCI6OTQ2Njg0ODAwLCJqdGkiOiIxIn0";
    private static final String CLIENT_ASSERTION_SIGNATURE =
            "I-3-sQbGUEvuKA_q0Yr1E5Dk3Cn3hrW7pY55ZrSoB-l966YQmmMqSLl90fxhT5Y2qIPrxTpg3rg7A39fGt3stQ";

    @BeforeEach
    void setup() {
        when(configService.getDocAppAuthorisationClientId()).thenReturn(CLIENT_ID.getValue());
        when(configService.getDocAppTokenSigningKeyAlias()).thenReturn(KEY_ID);
        when(configService.isDocAppNewAudClaimEnabled()).thenReturn(true);
        when(configService.getDocAppAudClaim()).thenReturn(new Audience(DOC_APP_AUD));
        when(kmsConnectionService.getPublicKey(any(GetPublicKeyRequest.class)))
                .thenReturn(GetPublicKeyResponse.builder().keyId(KEY_ID).build());
        when(kmsConnectionService.sign(any(SignRequest.class))).thenReturn(mockKmsReturn());
    }

    @Pact(consumer = "OrchTokenConsumer")
    RequestResponsePact validRequestReturnsValidAccessToken(PactDslWithProvider builder) {
        return builder.given("dummyAuthCode is a valid authorization code")
                .given("the JWT is signed with " + PRIVATE_JWT_KEY)
                .given("localHost is a valid resource URI")
                .given("the audience is " + DOC_APP_AUD)
                .uponReceiving("Valid auth code")
                .path("/" + DOC_APP_TOKEN_PATH)
                .method("POST")
                .body(
                        "client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer&"
                                + "code=dummyAuthCode&"
                                + "grant_type=authorization_code&"
                                + "resource="
                                + "http://localhost:1234/token"
                                + "&"
                                + "client_assertion="
                                + CLIENT_ASSERTION_HEADER
                                + "."
                                + CLIENT_ASSERTION_BODY
                                + "."
                                + CLIENT_ASSERTION_SIGNATURE
                                + "&"
                                + "client_id="
                                + CLIENT_ID.getValue())
                .matchHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
                .willRespondWith()
                .status(200)
                .body(
                        newJsonBody(
                                        (body) -> {
                                            body.stringType(ACCESS_TOKEN_FIELD, ACCESS_TOKEN_VALUE);
                                            body.stringType(TOKEN_TYPE_FIELD, TOKEN_TYPE_VALUE);
                                            body.integerType(EXPIRES_IN_FIELD, EXPIRES_IN_VALUE);
                                            body.stringType(URI_FIELD, URI_VALUE);
                                        })
                                .build())
                .toPact();
    }

    @Test
    @PactTestFor(
            providerName = "DcmawCriTokenProvider",
            pactMethod = "validRequestReturnsValidAccessToken",
            pactVersion = PactSpecVersion.V3)
    void getDocAppTokenSuccessResponse(MockServer mockServer) {
        when(configService.getDocAppBackendURI()).thenReturn(URI.create(mockServer.getUrl()));
        docAppCriService =
                new DocAppCriService(
                        configService, kmsConnectionService, new DocAppCriAPI(configService));

        TokenRequest tokenRequest;
        try (MockedStatic<NowHelper> mockedNowHelperClass = Mockito.mockStatic(NowHelper.class)) {
            mockedNowHelperClass
                    .when(NowHelper::now)
                    .thenReturn(Date.from(Instant.parse("2000-01-01T00:00:00.00Z")));
            mockedNowHelperClass
                    .when(() -> NowHelper.nowPlus(5L, ChronoUnit.MINUTES))
                    .thenReturn(Date.from(Instant.parse("2099-01-01T00:00:00.00Z")));
            try (var mockJwtId =
                    mockConstruction(
                            JWTID.class,
                            (mock, context) -> {
                                when(mock.getValue()).thenReturn("1");
                            })) {
                tokenRequest = docAppCriService.constructTokenRequest("dummyAuthCode");
            }
        }
        TokenResponse response = docAppCriService.sendTokenRequest(tokenRequest);

        assertThat(response.indicatesSuccess(), equalTo(true));
        assertThat(response.toHTTPResponse().getBody(), equalTo(getSuccessfulTokenHttpResponse()));
    }

    @Pact(consumer = "OrchTokenConsumer")
    RequestResponsePact invalidAuthCodeReturnsInvalidRequest(PactDslWithProvider builder) {
        return builder.given("dummyAuthCode is a invalid authorization code")
                .given("the JWT is signed with " + PRIVATE_JWT_KEY)
                .given("localHost is a valid resource URI")
                .given("the audience is " + DOC_APP_AUD)
                .uponReceiving("Invalid auth code")
                .path("/" + DOC_APP_TOKEN_PATH)
                .method("POST")
                .body(
                        "client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer&"
                                + "code=dummyAuthCode&"
                                + "grant_type=authorization_code&"
                                + "resource="
                                + "http://localhost:1234/token"
                                + "&"
                                + "client_assertion="
                                + CLIENT_ASSERTION_HEADER
                                + "."
                                + CLIENT_ASSERTION_BODY
                                + "."
                                + CLIENT_ASSERTION_SIGNATURE
                                + "&"
                                + "client_id="
                                + CLIENT_ID.getValue())
                .matchHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
                .willRespondWith()
                .status(400)
                .toPact();
    }

    @Test
    @PactTestFor(
            providerName = "DcmawCriTokenProvider",
            pactMethod = "invalidAuthCodeReturnsInvalidRequest",
            pactVersion = PactSpecVersion.V3)
    void getDocAppTokenErrorResponse(MockServer mockServer) {
        when(configService.getDocAppBackendURI()).thenReturn(URI.create(mockServer.getUrl()));
        docAppCriService =
                new DocAppCriService(
                        configService, kmsConnectionService, new DocAppCriAPI(configService));

        TokenRequest tokenRequest;
        try (MockedStatic<NowHelper> mockedNowHelperClass = Mockito.mockStatic(NowHelper.class)) {
            mockedNowHelperClass
                    .when(NowHelper::now)
                    .thenReturn(Date.from(Instant.parse("2000-01-01T00:00:00.00Z")));
            mockedNowHelperClass
                    .when(() -> NowHelper.nowPlus(5L, ChronoUnit.MINUTES))
                    .thenReturn(Date.from(Instant.parse("2099-01-01T00:00:00.00Z")));
            try (var mockJwtId =
                    mockConstruction(
                            JWTID.class,
                            (mock, context) -> {
                                when(mock.getValue()).thenReturn("1");
                            })) {
                tokenRequest = docAppCriService.constructTokenRequest("dummyAuthCode");
            }
        }
        TokenResponse response = docAppCriService.sendTokenRequest(tokenRequest);

        assertThat(response.indicatesSuccess(), equalTo(false));
        assertThat(response.toHTTPResponse().getStatusCode(), equalTo(400));
    }

    private SignResponse mockKmsReturn() {
        byte[] signature_bytes;

        try {
            signature_bytes =
                    ECDSA.transcodeSignatureToDER(
                            Base64.getUrlDecoder().decode(CLIENT_ASSERTION_SIGNATURE));
        } catch (JOSEException e) {
            throw new RuntimeException(e);
        }

        return SignResponse.builder()
                .signature(SdkBytes.fromByteArray(signature_bytes))
                .signingAlgorithm(SigningAlgorithmSpec.ECDSA_SHA_256)
                .keyId(KEY_ID)
                .build();
    }

    public String getSuccessfulTokenHttpResponse() {
        return "{"
                + "\""
                + ACCESS_TOKEN_FIELD
                + "\":\""
                + ACCESS_TOKEN_VALUE
                + "\","
                + "\""
                + TOKEN_TYPE_FIELD
                + "\":\""
                + TOKEN_TYPE_VALUE
                + "\","
                + "\""
                + EXPIRES_IN_FIELD
                + "\":"
                + EXPIRES_IN_VALUE
                + ","
                + "\""
                + URI_FIELD
                + "\":\""
                + URI_VALUE.replace("/", "\\/")
                + "\""
                + "}";
    }
}
