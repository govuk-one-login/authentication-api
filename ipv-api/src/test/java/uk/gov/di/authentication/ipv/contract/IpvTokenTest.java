package uk.gov.di.authentication.ipv.contract;

import au.com.dius.pact.consumer.MockServer;
import au.com.dius.pact.consumer.dsl.PactDslWithProvider;
import au.com.dius.pact.consumer.junit.MockServerConfig;
import au.com.dius.pact.consumer.junit5.PactConsumerTest;
import au.com.dius.pact.consumer.junit5.PactTestFor;
import au.com.dius.pact.core.model.PactSpecVersion;
import au.com.dius.pact.core.model.RequestResponsePact;
import au.com.dius.pact.core.model.annotations.Pact;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.crypto.impl.ECDSA;
import com.nimbusds.oauth2.sdk.*;
import com.nimbusds.oauth2.sdk.id.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import software.amazon.awssdk.core.SdkBytes;
import software.amazon.awssdk.services.kms.model.SignRequest;
import software.amazon.awssdk.services.kms.model.SignResponse;
import software.amazon.awssdk.services.kms.model.SigningAlgorithmSpec;
import uk.gov.di.authentication.ipv.services.IPVTokenService;
import uk.gov.di.orchestration.shared.helpers.*;
import uk.gov.di.orchestration.shared.services.*;

import java.net.URI;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Base64;
import java.util.Date;

import static au.com.dius.pact.consumer.dsl.LambdaDsl.newJsonBody;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@PactConsumerTest
@MockServerConfig(hostInterface = "localHost", port = "1234")
public class IpvTokenTest {
    private final ConfigurationService configService = mock(ConfigurationService.class);
    private final KmsConnectionService kmsConnectionService = mock(KmsConnectionService.class);
    private IPVTokenService ipvTokenService;

    private static final String IPV_AUD = "http://ipv/";
    private static final URI IPV_URI = URI.create(IPV_AUD);
    private static final ClientID CLIENT_ID = new ClientID("authOrchestrator");
    private static final String IPV_TOKEN_PATH = "token";
    private final String ACCESS_TOKEN_FIELD = "access_token";
    private final String TOKEN_TYPE_FIELD = "token_type";
    private final String EXPIRES_IN_FIELD = "expires_in";
    private final String ACCESS_TOKEN_VALUE = "740e5834-3a29-46b4-9a6f-16142fde533a";
    private final String TOKEN_TYPE_VALUE = "Bearer";
    private final Integer EXPIRES_IN_VALUE = 3600;
    private static final String KEY_ID = "14342354354353";

    // Generated by debugging tokenServiceTest when creating EC signing key
    private static final String PRIVATE_JWT_KEY =
            "{\"kty\":\"EC\",\"d\":\"A2cfN3vYKgOQ_r1S6PhGHCLLiVEqUshFYExrxMwkq_A\",\"crv\":\"P-256\",\"kid\":\"14342354354353\",\"x\":\"BMyQQqr3NEFYgb9sEo4hRBje_HHEsy87PbNIBGL4Uiw\",\"y\":\"qoXdkYVomy6HWT6yNLqjHSmYoICs6ioUF565Btx0apw\",\"alg\":\"ES256\"}";
    // Generated by debugging the token service when creating the request
    private static final String CLIENT_ASSERTION_HEADER =
            "eyJraWQiOiIxNDM0MjM1NDM1NDM1MyIsImFsZyI6IkVTMjU2In0";
    private static final String CLIENT_ASSERTION_BODY =
            "eyJzdWIiOiJhdXRoT3JjaGVzdHJhdG9yIiwiYXVkIjoiaHR0cDovL2lwdi8iLCJuYmYiOjk0NjY4NDgwMCwiaXNzIjoiYXV0aE9yY2hlc3RyYXRvciIsImV4cCI6NDA3MDkwODgwMCwiaWF0Ijo5NDY2ODQ4MDAsImp0aSI6IjEifQ";
    // Generated from jwt.io by using PRIVATE_JWT_KEY
    private static final String CLIENT_ASSERTION_SIGNATURE =
            "Oe86h2qN7LGSSqBWW7m2nZOuPzvupvH6DBlrp5VyNkb4gScUuLk9xKQpXf3IPUM8oLnVV4IuDbcKFWLUynV9EA";

    @BeforeEach
    void setUp() {
        ipvTokenService = new IPVTokenService(configService, kmsConnectionService);
        when(configService.getIPVAuthorisationClientId()).thenReturn(CLIENT_ID.getValue());
        when(configService.getIPVAudience()).thenReturn(IPV_URI);
        when(configService.getIPVTokenSigningKeyAlias()).thenReturn(KEY_ID);
        when(kmsConnectionService.sign(any(SignRequest.class))).thenReturn(mockKmsReturn());
    }

    @Pact(consumer = "OrchTokenConsumer")
    RequestResponsePact validRequestReturnsValidAccessToken(PactDslWithProvider builder) {
        return builder.given("dummyAuthCode is a valid authorization code")
                .given("the JWT is signed with " + PRIVATE_JWT_KEY)
                .given("the audience is " + IPV_AUD)
                .uponReceiving("Valid auth code")
                .path("/" + IPV_TOKEN_PATH)
                .method("POST")
                .body(
                        "client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer&"
                                + "code=dummyAuthCode&"
                                + "grant_type=authorization_code&"
                                + "resource="
                                + "http://localhost:1234/token"
                                + "&"
                                + "client_assertion="
                                + CLIENT_ASSERTION_HEADER
                                + "."
                                + CLIENT_ASSERTION_BODY
                                + "."
                                + CLIENT_ASSERTION_SIGNATURE
                                + "&"
                                + "client_id="
                                + CLIENT_ID.getValue())
                .matchHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
                .willRespondWith()
                .status(200)
                .body(
                        newJsonBody(
                                        (body) -> {
                                            body.stringType(ACCESS_TOKEN_FIELD, ACCESS_TOKEN_VALUE);
                                            body.stringType(TOKEN_TYPE_FIELD, TOKEN_TYPE_VALUE);
                                            body.integerType(EXPIRES_IN_FIELD, EXPIRES_IN_VALUE);
                                        })
                                .build())
                .toPact();
    }

    @Test
    @PactTestFor(
            providerName = "IpvCoreBackTokenProvider",
            pactMethod = "validRequestReturnsValidAccessToken",
            pactVersion = PactSpecVersion.V3)
    void getIPVTokenSuccessResponse(MockServer mockServer) {
        when(configService.getIPVBackendURI()).thenReturn(URI.create(mockServer.getUrl()));

        TokenResponse tokenResponse;
        try (MockedStatic<NowHelper> mockedNowHelperClass = Mockito.mockStatic(NowHelper.class)) {
            mockedNowHelperClass
                    .when(NowHelper::now)
                    .thenReturn(Date.from(Instant.parse("2000-01-01T00:00:00.00Z")));
            mockedNowHelperClass
                    .when(() -> NowHelper.nowPlus(5L, ChronoUnit.MINUTES))
                    .thenReturn(Date.from(Instant.parse("2099-01-01T00:00:00.00Z")));
            try (var mockJwtId =
                    mockConstruction(
                            JWTID.class,
                            (mock, context) -> {
                                when(mock.getValue()).thenReturn("1");
                            })) {
                tokenResponse = ipvTokenService.getToken("dummyAuthCode");
            }
        }

        assertThat(tokenResponse.indicatesSuccess(), equalTo(true));
        assertThat(
                tokenResponse.toSuccessResponse().getTokens().toString(),
                equalTo(getSuccessfulTokenHttpResponse()));
    }

    @Pact(consumer = "OrchTokenConsumer")
    RequestResponsePact invalidAuthCodeReturnsInvalidRequest(PactDslWithProvider builder) {
        return builder.given("dummyInvalidAuthCode is a invalid authorization code")
                .given("the JWT is signed with " + PRIVATE_JWT_KEY)
                .given("the audience is " + IPV_AUD)
                .uponReceiving("Invalid auth code")
                .path("/" + IPV_TOKEN_PATH)
                .method("POST")
                .body(
                        "client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer&"
                                + "code=dummyInvalidAuthCode&"
                                + "grant_type=authorization_code&"
                                + "resource="
                                + "http://localhost:1234/token"
                                + "&"
                                + "client_assertion="
                                + CLIENT_ASSERTION_HEADER
                                + "."
                                + CLIENT_ASSERTION_BODY
                                + "."
                                + CLIENT_ASSERTION_SIGNATURE
                                + "&"
                                + "client_id="
                                + CLIENT_ID.getValue())
                .matchHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
                .willRespondWith()
                .status(400)
                .toPact();
    }

    @Test
    @PactTestFor(
            providerName = "IpvCoreBackTokenProvider",
            pactMethod = "invalidAuthCodeReturnsInvalidRequest",
            pactVersion = PactSpecVersion.V3)
    void getIPVTokenErrorResponse(MockServer mockServer) {
        when(configService.getIPVBackendURI()).thenReturn(URI.create(mockServer.getUrl()));

        TokenResponse tokenResponse;
        try (MockedStatic<NowHelper> mockedNowHelperClass = Mockito.mockStatic(NowHelper.class)) {
            mockedNowHelperClass
                    .when(NowHelper::now)
                    .thenReturn(Date.from(Instant.parse("2000-01-01T00:00:00.00Z")));
            mockedNowHelperClass
                    .when(() -> NowHelper.nowPlus(5L, ChronoUnit.MINUTES))
                    .thenReturn(Date.from(Instant.parse("2099-01-01T00:00:00.00Z")));
            try (var mockJwtId =
                    mockConstruction(
                            JWTID.class,
                            (mock, context) -> {
                                when(mock.getValue()).thenReturn("1");
                            })) {
                tokenResponse = ipvTokenService.getToken("dummyInvalidAuthCode");
            }
        }

        assertThat(tokenResponse.indicatesSuccess(), equalTo(false));
        assertThat(tokenResponse.toHTTPResponse().getStatusCode(), equalTo(400));
    }

    private SignResponse mockKmsReturn() {
        byte[] signature_bytes;

        try {
            signature_bytes =
                    ECDSA.transcodeSignatureToDER(
                            Base64.getDecoder().decode(CLIENT_ASSERTION_SIGNATURE));
        } catch (JOSEException e) {
            throw new RuntimeException(e);
        }

        return SignResponse.builder()
                .signature(SdkBytes.fromByteArray(signature_bytes))
                .signingAlgorithm(SigningAlgorithmSpec.ECDSA_SHA_256)
                .keyId(KEY_ID)
                .build();
    }

    public String getSuccessfulTokenHttpResponse() {
        return "{"
                + "\""
                + ACCESS_TOKEN_FIELD
                + "\":\""
                + ACCESS_TOKEN_VALUE
                + "\","
                + "\""
                + TOKEN_TYPE_FIELD
                + "\":\""
                + TOKEN_TYPE_VALUE
                + "\","
                + "\""
                + EXPIRES_IN_FIELD
                + "\":"
                + EXPIRES_IN_VALUE
                + "}";
    }
}
